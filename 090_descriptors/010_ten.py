# https://docs.python.org/3/howto/descriptor.html
# Самая соль https://docs.python.org/3/howto/descriptor.html#closing-thoughts
# Дескриптор - это объект, класса реализующего методы __get__(), __set()__,
# __delete()__ Эти три метода называются протоколом дескриптора. Если
# определен только метод __get__() то такой дескриптор называется "дескриптор
# без данных", если определены ещё и __set()__ или  __delete()__ или оба
# вместе, то это "дескриптор данных"
# Ключевая фишка почему это всё работает: магический метод __get__()
# определен в классе АТРИБУТА к которому обращаются через точку '.' именно
# тогда и срабатывает __get__(), т.е. Атрибут digit10 ссылается на
# объект-дескриптор, когда к нему обращаются через точку '.' a.digit10 тогда
# и срабатывает метод __get__() дескриптора
# @property, @staticmethod, @classmethod - это всё встроенные дескрипторы
# реализованные на С. Дескриптор не обязательно должен быть реализован в виде
# декоратора, просто это удобно и системные дескрипторы реализованы в виде
# декораторов.

class Ten:
    def __get__(self, instance, owner):
        return 10

    def __set__(self, instance, value):
        pass  # атрибут "только для чтения"
        # raise AttributeError("can't set attribute")


class A:
    # Обычный атрибут класса, "прямой" доступ
    digit = 5
    # Атрибут класса, доступ к которому осуществляется с помощью дескриптора
    digit10 = Ten()
    pass  # тут поставить точку останова, чтобы убедится, что digit10 = __main__.Ten


a = A()
print(a.digit10)
#  Переменная digit10 в словаре a.__dict__ отсутствует(т.к. это переменная
#  класса и находится в пространстве имен класса), но её создания не происходит!
#  вместо этого вызывается метод класса Ten.__set__(). Если бы __set__() не был
#  определен, то создалась бы локальная переменная a.__dict__['digit10'] = 100,
#  таким образом дескриптор данных(т.е. у которого есть __set__()) имеет
#  ПРИОРИТЕТ над локальным словарем __dict__
a.digit10 = 100  # a.digit10 по прежнему = 10!
print(a.digit10)
