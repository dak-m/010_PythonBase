# списки являются ИЗМЕНЯЕМЫМИ, относятся к ПОСЛЕДОВАТЕЛЬНОСТЯМ (т.е.
# упорядочены)
import copy


# примеры распаковки списков(кортежей и т.д.)
first, *mid, last = '1 2 3 4 5'.split()


# распаковка в параметры функции
def multi(a, b, c):
    return a * b * c


arg = [2, 3, 4]
d = multi(*arg)  # <=> arg1, arg2, arg3 = *arg
e = multi(arg[0], *arg[1:])


def summ(*args):
    return sum(args)


f1 = summ(*arg)
f2 = summ(1, 2, 3)

# работа со списком

# поверхностное копирование, т.е. копия только верхнего уровня,
# вложенные списки копируются как ссылки, которые по факту ссылаются на один и тотже объект
x = [53, 68, ["А", "В", "С"]]
y = x[:]
y[1] = 40
x[2][0] = 'QQQ'

# глубокое копирование, рекурсивное создание новых объектов
x1 = [53, 68, ["А", "В", "С"]]
y1 = copy.deepcopy(x1)
y1[1] = 40
x1[2][0] = 'QQQ'

# встака в срез
arg[1:1] = [2.5]
arg.insert(3, 3.5)

# работает это так: сначало удаляются элементы попавшие в срез, а на их место вставляются новые
# удаляются(если по порядку) 2-ой, 3-ий, 4-ый или с индексами 1,2,3 (4 не включатся)
# добавляется на их место один элемент
arg[1:4] = [3]
# удалить элементы можно присвоив cрезу пустой список
arg[1:3] = []

# обнулить элементы с четными индексами
x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
y = [0] * len(x[1::2])
x[1::2] = y
# удалить каждый второй элемент, точнее del не удаляет а РАЗРЫВАЕТ СВЯЗЬ переменной с объектом
del x[1::2]


# генераторы списка, они же list comprehension

codes = [s + z + c for s in "MF" for z in "SMLX" for c in "BGW"
         if not (s == "F" and z == "X")]

leaps = [y for y in range(1900, 1940)
         if (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)]

# генерация списка распаковкой
*yyy, = 'qwerty'
*xxx, = range(10)
# эквивалент:
xxx1 = list(range(10))
