# Замыкание это внутренняя функция со своим "окружением" т.е. переменными
# которые в ней не объявляются, но используются. Идея такая: хотя внешняя
# функция уже отработала, внутрення функция "живет" пока на неё есть ссылка,
# а также "живет" и переменная arg, которая в ней используется. Причем для
# f1 и f2 будут разные окружения, в каждом из окружений значения arg будут
# различны.
def outer(arg):
    def inner():
        print(f'{arg}')
    return inner


f1 = outer('1')
f1()

f2 = outer('2')
f2()

# Кортеж, содержащий переменные, попавшие в замыкание функции
z = f1.__closure__

# А вот и сами значения, их даже можно изменить!
z[0].cell_contents = z[0].cell_contents + '!'
print(z[0].cell_contents)
