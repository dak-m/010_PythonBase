# Итерируемый объект - объект, класса реализующего методы __iter__ или метод __getitem__
# проще говоря это некий объект, который можно итерировать т.е. обходить в цикле
# Итератор — это объект возвращаемый функцией iter(), с помощью которого происходит обход итерируемого объекта.
# Итератор с точки зрения питона - это любой объект у которого есть метод __next__
# В первую очередь питоном используется __iter__, если его нет то __getitem__
# Примеры встроенных итераторов: iter([]), iter({}), iter(''), iter({}.values()), iter({}.items())

# Вариант 1:
# Чтобы можно было итерироваться по объекту, у него должен быть метод __iter__, который вернет объект-итератор.
# У объекта-итератора(!!!) должен быть метод __next__, который будет возвращать следующий элемент из объекта,
# по которому итерируемся, либо кидать ошибку StopIteration (MyIterable3)

# Вариант 2:
# Чтобы можно было итерироваться по объекту, у него должен быть метод __getitem__ (MyIterable2)
# По некоторым данным это устаревший способ и предпочтение Варианту 1

# Вариант 3:
# Чтобы можно было итерироваться по объекту, у него должен быть метод __call__ возвращающий след.значение (MyIterable4)

# В данном частном случае сам же объект(!) и является итератором, это упрощенный дизайн, как бы "два в одном"
# но в общем случае объект и итератор не обязаны быть одним и тем же объектом (пример MyIterable3)
# Например, у списка list итератором является отдельный объект list_iterator, а не сам список

class MyIterable1(object):
    def __init__(self):
        self.items = [1, 2, 3, 4]

    def __iter__(self):
        self.index = 0
        # в данном случае сам же объект и является итератором, но итератор может быть реализован и другим классом
        # таким образом сам итерируемый объект и итератор это могут быть 2 разных объекта (или один и тот же, как тут)
        return self

    def __next__(self):
        if self.index < len(self.items):
            element = self.items[self.index]
            self.index += 1
            return element
        else:
            raise StopIteration


obj = MyIterable1()  # итерируемый объект
iterat = iter(obj)  # итератор

print(next(iterat))
print(next(iterat))
print(next(iterat))

print('*'*50)

# В данном случае даже __next__ не нужен, можно просто вернуть итератор агрегируемого списка
# Т.е. если нужно обходить стандартную коллекцию, то можно просто вернуть её "встроенный" итератор
class MyIterable11(object):
    def __init__(self):
        self.items = [1, 2, 3, 4]

    def __iter__(self):
        return iter(self.items)


obj11 = MyIterable11()  # итерируемый объект
iterat11 = iter(obj11)  # итератор

print(next(iterat11))
print(next(iterat11))
print(next(iterat11))
